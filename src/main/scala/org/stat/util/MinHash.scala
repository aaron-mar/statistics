package org.stat.util

import java.io.Serializable
import java.math.BigInteger

import org.apache.accumulo.core.client.lexicoder.impl.ByteUtils
import org.stat.accumulo.AccumuloUtil.{EMPTY_BYTES, STRING_LEXICODER, intToBytes}

import scala.collection.mutable.ListBuffer

object MinHash {
    val MINHASH_MOD = 401

    // These random numbers were generated by a program and preserved here
    val MINHASH_COEFFICIENT_PAIRS = Array(
        new CoefficientPair(62, 92),
        new CoefficientPair(27, 59),
        new CoefficientPair(22, 31),
        new CoefficientPair(55, 25),
        new CoefficientPair(96, 25),
        new CoefficientPair(90, 87),
        new CoefficientPair(21, 5),
        new CoefficientPair(29, 50),
        new CoefficientPair(18, 26),
        new CoefficientPair(75, 20),
        new CoefficientPair(28, 65),
        new CoefficientPair(8, 9),
        new CoefficientPair(47, 68),
        new CoefficientPair(60, 90),
        new CoefficientPair(42, 50),
        new CoefficientPair(68, 67),
        new CoefficientPair(92, 39),
        new CoefficientPair(10, 62),
        new CoefficientPair(34, 72),
        new CoefficientPair(96, 92),
        new CoefficientPair(10, 11),
        new CoefficientPair(15, 25),
        new CoefficientPair(48, 89),
        new CoefficientPair(82, 40),
        new CoefficientPair(95, 62),
        new CoefficientPair(23, 39),
        new CoefficientPair(28, 71),
        new CoefficientPair(88, 85),
        new CoefficientPair(65, 22),
        new CoefficientPair(96, 19),
        new CoefficientPair(77, 55),
        new CoefficientPair(89, 15),
        new CoefficientPair(35, 48),
        new CoefficientPair(4, 70),
        new CoefficientPair(8, 60),
        new CoefficientPair(22, 88),
        new CoefficientPair(81, 94),
        new CoefficientPair(63, 86),
        new CoefficientPair(52, 83),
        new CoefficientPair(100, 29),
        new CoefficientPair(32, 13),
        new CoefficientPair(96, 62),
        new CoefficientPair(37, 1),
        new CoefficientPair(6, 16),
        new CoefficientPair(99, 6),
        new CoefficientPair(55, 38),
        new CoefficientPair(41, 15),
        new CoefficientPair(6, 77),
        new CoefficientPair(51, 47),
        new CoefficientPair(65, 78),
        new CoefficientPair(20, 70),
        new CoefficientPair(81, 76),
        new CoefficientPair(60, 54),
        new CoefficientPair(67, 73),
        new CoefficientPair(36, 45),
        new CoefficientPair(93, 34),
        new CoefficientPair(40, 19),
        new CoefficientPair(9, 21),
        new CoefficientPair(59, 93),
        new CoefficientPair(50, 53),
        new CoefficientPair(97, 16),
        new CoefficientPair(24, 85),
        new CoefficientPair(44, 55),
        new CoefficientPair(67, 73),
        new CoefficientPair(74, 14),
        new CoefficientPair(41, 45),
        new CoefficientPair(45, 10),
        new CoefficientPair(39, 60),
        new CoefficientPair(80, 70),
        new CoefficientPair(8, 82),
        new CoefficientPair(63, 29),
        new CoefficientPair(70, 95),
        new CoefficientPair(47, 40),
        new CoefficientPair(50, 31),
        new CoefficientPair(84, 95),
        new CoefficientPair(99, 2),
        new CoefficientPair(37, 98),
        new CoefficientPair(14, 63),
        new CoefficientPair(43, 7),
        new CoefficientPair(99, 68),
        new CoefficientPair(10, 23),
        new CoefficientPair(97, 90),
        new CoefficientPair(82, 32),
        new CoefficientPair(20, 59),
        new CoefficientPair(5, 18),
        new CoefficientPair(67, 32),
        new CoefficientPair(43, 88),
        new CoefficientPair(16, 82),
        new CoefficientPair(27, 73),
        new CoefficientPair(88, 38),
        new CoefficientPair(78, 23),
        new CoefficientPair(26, 84),
        new CoefficientPair(71, 80),
        new CoefficientPair(40, 85),
        new CoefficientPair(43, 76),
        new CoefficientPair(95, 6),
        new CoefficientPair(66, 99),
        new CoefficientPair(11, 67),
        new CoefficientPair(73, 73),
        new CoefficientPair(77, 48)
    )

    /**
      * Find the jaccard similarity between the two signatures
      * @param signature1 The first sets signature.
      * @param signature2 The second sets signature.
      * @return
      */
    def jaccardSimularity(signature1: Array[Int], signature2: Array[Int]): Int = {
        val intersect = signature1.intersect(signature2).distinct.length
        val union = signature1.union(signature2).distinct.length
        (signature1.intersect(signature2).distinct.length * 100) / signature1.union(signature2).distinct.length
    }

    /**
      * Generate a signature based on the permutation specified by hashes1 and hashes2.
      *
      * @param hashes1 The first set of hashes.
      * @param hashes2 The second set of hashes.
      * @return
      */
    def signature(hashes1: Array[Int], hashes2: Array[Int]) : Array[Int] = {
        val sig = hashes1.zip(hashes2).map{h => h._1.min(h._2)}

        sig
    }

    /**
      * Create a set of hashes for the row of data for a particular element in a set (the device type specifies the set).
      * This is suitable for creating a minhash signature for a set of data.
      *
      * @param keyword The keyword
      * @param market The market
      * @param location The location
      * @param rank The rank
      * @param url The URL
      * @return An array of integers that represents the signature of the set of data.
      */
    def hashes(uniqueValuePrime: Int, keyword: String, market: String, location: String, rank: Int, url: String) : Array[Int] = {
        for (coefficient <- MINHASH_COEFFICIENT_PAIRS)
            yield hashValue(coefficient, uniqueValuePrime, keyword, market, location, rank, url)
    }

    /**
      * Hashing the value so that it creates a unique value is done by converting all the information into a single
      * byte array (ie. by concatenating everything), then converting the byte array to a BigInteger. A BigInteger's
      * implementation is a matrix of max int by max int, so can hold large numbers. Holding a converted number should
      * be possible.
      *
      * The hashing algorithm typically seen in write ups are of the form: ((a * x) + b) % c
      *
      * where a and b are considered the coefficients. The value of c is a prime number and typically the first prime
      * number just after the number of times to hash (ie. the permutations).
      *
      * @param coefficient The a and b coefficents to construct hash values with.
      * @param keyword The stat keyword.
      * @param market The stat market.
      * @param location The stat location.
      * @param rank The stat rank.
      * @param url The stat url.
      * @return A integer hash value.
      */
    def hashValue(coefficient: CoefficientPair, uniqueValuePrime: Int,
                  keyword: String, market: String, location: String, rank: Int, url: String): Int = {
        // Questionable if this is the best way to generate the hash seed.. tried using converting to a binary
        // then loading it BigInteger, but that did not work too well
        val hashSeed = (keyword + cs(market) + cs(location) + rank.toString + url).hashCode
        // Generate the hash value given the coefficient and mod: hash(x) = (a*x + b) % mod
        Math.abs((hashSeed * coefficient.a + coefficient.b) % uniqueValuePrime)
    }

    def cs(v: String): String = if (v == null) "" else v

    def nextPrime(n: Int): Int = {
        def iterate(m: Int): Int = {
            if(isPrime(m)) m
            else iterate(m +1)
        }
        iterate(n)
    }

    def isPrime(n: Int): Boolean = ! ((2 until n-1) exists (n % _ == 0))
}

class CoefficientPair(val a: Int, val b: Int) extends Serializable {
    def canEqual(other: Any): Boolean = other.isInstanceOf[CoefficientPair]

    override def equals(other: Any): Boolean = other match {
        case that: CoefficientPair =>
            (that canEqual this) &&
                a == that.a &&
                b == that.b
        case _ => false
    }

    override def hashCode(): Int = {
        val state = Seq(a, b)
        state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
    }
}
